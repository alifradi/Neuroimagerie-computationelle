---
title: "05_Segmentation d'images cérébrales"
author: "Ali FRADY"
date: "22/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r set environment, include=FALSE}
library(reticulate)
use_condaenv()
```


Validation de la segmentation
Cette section vise à introduire quelques critères de validation utilisés en traitement d’images pour évaluer les performances d’une méthode de segmentation d’images. Les masques « csf_mask.jpg », « wm_mask.jpg » et « gm_mask.jpg » calculés à la section III) correspondent à la vérité terrain pour les régions csf, wm et gm que l’on cherche à segmenter. En vous servant de cette vérité terrain ainsi que des masques que vous avez obtenus par votre méthode de classification :

1) Calculez le coefficient de DICE pour chaque région d’intérêt.

```{python}
import numpy as np
import cv2
from matplotlib import pyplot as plt
def binarizing_mask(img):
    _, th = cv2.threshold(img, 10 , 255, cv2.THRESH_BINARY)
    return th
    
wm_mask      = cv2.imread('data/wm_mask.jpg')
WhiteMatter  = cv2.imread('data/WhiteMatter.jpg')
WhiteMatter  = cv2.resize(WhiteMatter, (wm_mask.shape[1],wm_mask.shape[0]))

gm_mask    = cv2.imread('data/gm_mask.jpg')
GrayMatter = cv2.imread('data/GrayMatter.jpg')
GrayMatter  = cv2.resize(GrayMatter, (gm_mask.shape[1],gm_mask.shape[0]))

csf_mask      = cv2.imread('data/csf_mask.jpg')
CSFMask       = cv2.imread('data/CSF.jpg')
CSFMask       = cv2.resize(CSFMask, (csf_mask.shape[1], csf_mask.shape[0]))


def dice_coef(img, img2):
  if img.shape != img2.shape:
    raise ValueError("Shape mismatch: img and img2 must have to be of the same shape.")
  else:
    lenIntersection=0
    for i in range(img.shape[0]):
      for j in range(img.shape[1]):
        if ( img[i][j] != 0 and img2[i][j] != 0 ):
          lenIntersection+=1
    lenimg=img.shape[0]*img.shape[1]
    lenimg2=img2.shape[0]*img2.shape[1]
    value = (2. * lenIntersection  / (lenimg + lenimg2))
  return value
```

```{python}
dice_coef(wm_mask,    WhiteMatter) *100
dice_coef(GrayMatter, gm_mask)*100
dice_coef(csf_mask,   CSFMask)*100

```
```{python}
plt.subplot(1, 2, 1)
plt.imshow(wm_mask),plt.title('wm_mask') 
plt.subplot(1, 2, 2)
plt.imshow(WhiteMatter),plt.title('wm_mask_kmeans') 
plt.show()


plt.subplot(1, 2, 1)
plt.imshow(gm_mask),plt.title('gm_mask') 
plt.subplot(1, 2, 2)
plt.imshow(GrayMatter),plt.title('gm_mask_kmeans') 
plt.show()


plt.subplot(1, 2, 1)
plt.imshow(csf_mask),plt.title('csf_mask') 
plt.subplot(1, 2, 2)
plt.imshow(CSFMask),plt.title('CSFMask_kmeans') 
plt.show()
```




2) Calculez pour chaque régions d’intérêt le nombre de faux positifs (FP), faux négatifs (FN), vrai positifs (VP) et vrai négatifs (VN)






```{r}
ActualwhiteMatter = as.vector(py$wm_mask)
PredictedWhite    = as.vector(py$WhiteMatter)

ActualGrayeMatter = as.vector(py$gm_mask)
PredictedGray     = as.vector(py$GrayMatter)

ActualwhiteMatter = as.vector(py$csf_mask)
PredictedCSF      = as.vector(py$CSFMask)


dataConfusion = data.frame()
```

